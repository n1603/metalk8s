const YAML = require('yaml');
const fs = require('fs');
import Generator from 'openapi-to-flowtype/dist/Generator';
const prettier = require('prettier');

export const DEFAULT_PRETTIER_OPTIONS = {
  parser: 'babel',
};

export function generateClient(crdFile: string, destinationFile: string) {
  const prettierOptions = {
    ...DEFAULT_PRETTIER_OPTIONS,
    ...( prettier.resolveConfig.sync( destinationFile ) || {} )
  };
  
  const file = fs.readFileSync(crdFile, 'utf8');
  const crdSpec = YAML.parse(file);
  
  const generator = new Generator();
  
  const typePrefix = 'Metalk8s' + crdSpec.spec.version.replace(/^\w/, (c) => c.toUpperCase());
  
  const isClusterScoped = crdSpec.spec.scope === 'Cluster';
  const isNamespacedScoped = crdSpec.spec.scope === 'Namespaced';
  
  const clusterOrNamespacedCustomObject = isClusterScoped ? `ClusterCustomObject(
    '${crdSpec.spec.group}',
    '${crdSpec.spec.version}',
    '${crdSpec.spec.names.plural}',` : `NamespacedCustomObject(
      '${crdSpec.spec.group}',
      '${crdSpec.spec.version}',
      namespace,
      '${crdSpec.spec.names.plural}',`

  const generateTypeDefinition = (typeName: string, typeDefinition) => `export type ${typeName} = ${generator.propertiesTemplate(
    generator.propertiesList( typeDefinition )
  ).replace( /"/g, '' )};`;

  const singleName = typePrefix + crdSpec.spec.names.kind;
  const singleType = generateTypeDefinition(singleName, crdSpec.spec.validation.openAPIV3Schema);
  
  const listName = typePrefix+crdSpec.spec.names.listKind;
  const listType = `export type ${listName} = {
    body: {items: ${singleName}[]};
  }`;
  
  const generatedCLient = `
  //@flow
  // /!\\ WARNING :  THIS FILE IS AUTOGENERATED FROM A KUBERNETES CUSTOM RESOURCE DEFINITION FILE. DO NOT CHANGE IT, use ui-metalk8s-client-generator to update it.
  import { customObjects } from './api';
  export type Result<T> = T | {error: any};
  
  ${singleType}
  ${listType}
  
  export async function get${listName}(${isNamespacedScoped ? 'namespace: string' : ''}): Promise<Result<${listName}>> {
    if (!customObjects) {
      return { error: 'customObject has not yet been initialized' };
    }
    try {
      return await customObjects.list${clusterOrNamespacedCustomObject}
      );
    } catch (error) {
      return { error };
    }
  }

  export async function get${singleName}(${isNamespacedScoped ? 'namespace: string, ' : ''}${singleName}Name: string): Promise<Result<${singleName}>> {
    if (!customObjects) {
      return { error: 'customObject has not yet been initialized' };
    }
    try {
      return await customObjects.get${clusterOrNamespacedCustomObject}
        ${singleName}Name,
      );
    } catch (error) {
      return { error };
    }
  }
  
  export async function delete${singleName}(${isNamespacedScoped ? 'namespace: string, ' : ''}${singleName}Name: string) {
    if (!customObjects) {
      return { error: 'customObject has not yet been initialized' };
    }
    try {
      return await customObjects.delete${clusterOrNamespacedCustomObject}
        ${singleName}Name,
        {},
      );
    } catch (error) {
      return { error };
    }
  }
  
  export async function create${singleName}(${isNamespacedScoped ? 'namespace: string, ' : ''}body: ${singleName}): Promise<Result<${singleName}>> {
    if (!customObjects) {
      return { error: 'customObject has not yet been initialized' };
    }
    try {
      return await customObjects.create${clusterOrNamespacedCustomObject}
        body,
      );
    } catch (error) {
      return { error };
    }
  }
  
  export async function patch${singleName}(${isNamespacedScoped ? 'namespace: string, ' : ''}body: $Shape<${singleName}>): Promise<Result<${singleName}>> {
    if (!customObjects) {
      return { error: 'customObject has not yet been initialized' };
    }
    try {
      return await customObjects.patch${clusterOrNamespacedCustomObject}
        body,
      );
    } catch (error) {
      return { error };
    }
  }
  `;
  
  return prettier.format( generatedCLient, prettierOptions );
}